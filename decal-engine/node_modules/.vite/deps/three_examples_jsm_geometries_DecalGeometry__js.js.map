{
  "version": 3,
  "sources": ["../../three/examples/jsm/geometries/DecalGeometry.js"],
  "sourcesContent": ["import {\r\n\tBufferGeometry,\r\n\tEuler,\r\n\tFloat32BufferAttribute,\r\n\tMatrix3,\r\n\tMatrix4,\r\n\tMesh,\r\n\tVector3\r\n} from 'three';\r\n\r\n/**\r\n * This class can be used to create a decal mesh that serves different kinds of purposes e.g.\r\n * adding unique details to models, performing dynamic visual environmental changes or covering seams.\r\n *\r\n * Please not that decal projections can be distorted when used around corners. More information at\r\n * this GitHub issue: [Decal projections without distortions]{@link https://github.com/mrdoob/three.js/issues/21187}.\r\n *\r\n * Reference: [How to project decals]{@link http://blog.wolfire.com/2009/06/how-to-project-decals/}\r\n *\r\n * ```js\r\n * const geometry = new DecalGeometry( mesh, position, orientation, size );\r\n * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );\r\n * const mesh = new THREE.Mesh( geometry, material );\r\n * scene.add( mesh );\r\n * ```\r\n *\r\n * @augments BufferGeometry\r\n * @three_import import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';\r\n */\r\nclass DecalGeometry extends BufferGeometry {\r\n\r\n\t/**\r\n\t * Constructs a new decal geometry.\r\n\t *\r\n\t * @param {Mesh} [mesh] - The base mesh the decal should be projected on.\r\n\t * @param {Vector3} [position] - The position of the decal projector.\r\n\t * @param {Euler} [orientation] - The orientation of the decal projector.\r\n\t * @param {Vector3} [size] - Tje scale of the decal projector.\r\n\t */\r\n\tconstructor( mesh = new Mesh(), position = new Vector3(), orientation = new Euler(), size = new Vector3( 1, 1, 1 ) ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\t// buffers\r\n\r\n\t\tconst vertices = [];\r\n\t\tconst normals = [];\r\n\t\tconst uvs = [];\r\n\r\n\t\t// helpers\r\n\r\n\t\tconst plane = new Vector3();\r\n\r\n\t\tconst normalMatrix = new Matrix3().getNormalMatrix( mesh.matrixWorld );\r\n\r\n\t\t// this matrix represents the transformation of the decal projector\r\n\r\n\t\tconst projectorMatrix = new Matrix4();\r\n\t\tprojectorMatrix.makeRotationFromEuler( orientation );\r\n\t\tprojectorMatrix.setPosition( position );\r\n\r\n\t\tconst projectorMatrixInverse = new Matrix4();\r\n\t\tprojectorMatrixInverse.copy( projectorMatrix ).invert();\r\n\r\n\t\t// generate buffers\r\n\r\n\t\tgenerate();\r\n\r\n\t\t// build geometry\r\n\r\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t\tif ( normals.length > 0 ) {\r\n\r\n\t\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tfunction generate() {\r\n\r\n\t\t\tlet decalVertices = [];\r\n\r\n\t\t\tconst vertex = new Vector3();\r\n\t\t\tconst normal = new Vector3();\r\n\r\n\t\t\t// handle different geometry types\r\n\r\n\t\t\tconst geometry = mesh.geometry;\r\n\r\n\t\t\tconst positionAttribute = geometry.attributes.position;\r\n\t\t\tconst normalAttribute = geometry.attributes.normal;\r\n\r\n\t\t\t// first, create an array of 'DecalVertex' objects\r\n\t\t\t// three consecutive 'DecalVertex' objects represent a single face\r\n\t\t\t//\r\n\t\t\t// this data structure will be later used to perform the clipping\r\n\r\n\t\t\tif ( geometry.index !== null ) {\r\n\r\n\t\t\t\t// indexed BufferGeometry\r\n\r\n\t\t\t\tconst index = geometry.index;\r\n\r\n\t\t\t\tfor ( let i = 0; i < index.count; i ++ ) {\r\n\r\n\t\t\t\t\tvertex.fromBufferAttribute( positionAttribute, index.getX( i ) );\r\n\r\n\t\t\t\t\tif ( normalAttribute ) {\r\n\r\n\t\t\t\t\t\tnormal.fromBufferAttribute( normalAttribute, index.getX( i ) );\r\n\t\t\t\t\t\tpushDecalVertex( decalVertices, vertex, normal );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tpushDecalVertex( decalVertices, vertex );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( positionAttribute === undefined ) return; // empty geometry\r\n\r\n\t\t\t\t// non-indexed BufferGeometry\r\n\r\n\t\t\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\r\n\r\n\t\t\t\t\tvertex.fromBufferAttribute( positionAttribute, i );\r\n\r\n\t\t\t\t\tif ( normalAttribute ) {\r\n\r\n\t\t\t\t\t\tnormal.fromBufferAttribute( normalAttribute, i );\r\n\t\t\t\t\t\tpushDecalVertex( decalVertices, vertex, normal );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tpushDecalVertex( decalVertices, vertex );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// second, clip the geometry so that it doesn't extend out from the projector\r\n\r\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 1, 0, 0 ) );\r\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( - 1, 0, 0 ) );\r\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, 1, 0 ) );\r\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, - 1, 0 ) );\r\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, 0, 1 ) );\r\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, 0, - 1 ) );\r\n\r\n\t\t\t// third, generate final vertices, normals and uvs\r\n\r\n\t\t\tfor ( let i = 0; i < decalVertices.length; i ++ ) {\r\n\r\n\t\t\t\tconst decalVertex = decalVertices[ i ];\r\n\r\n\t\t\t\t// create texture coordinates (we are still in projector space)\r\n\r\n\t\t\t\tuvs.push(\r\n\t\t\t\t\t0.5 + ( decalVertex.position.x / size.x ),\r\n\t\t\t\t\t0.5 + ( decalVertex.position.y / size.y )\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// transform the vertex back to world space\r\n\r\n\t\t\t\tdecalVertex.position.applyMatrix4( projectorMatrix );\r\n\r\n\t\t\t\t// now create vertex and normal buffer data\r\n\r\n\t\t\t\tvertices.push( decalVertex.position.x, decalVertex.position.y, decalVertex.position.z );\r\n\r\n\t\t\t\tif ( decalVertex.normal !== null ) {\r\n\r\n\t\t\t\t\tnormals.push( decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction pushDecalVertex( decalVertices, vertex, normal = null ) {\r\n\r\n\t\t\t// transform the vertex to world space, then to projector space\r\n\r\n\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\r\n\t\t\tvertex.applyMatrix4( projectorMatrixInverse );\r\n\r\n\t\t\tif ( normal ) {\r\n\r\n\t\t\t\tnormal.applyNormalMatrix( normalMatrix );\r\n\t\t\t\tdecalVertices.push( new DecalVertex( vertex.clone(), normal.clone() ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tdecalVertices.push( new DecalVertex( vertex.clone() ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction clipGeometry( inVertices, plane ) {\r\n\r\n\t\t\tconst outVertices = [];\r\n\r\n\t\t\tconst s = 0.5 * Math.abs( size.dot( plane ) );\r\n\r\n\t\t\t// a single iteration clips one face,\r\n\t\t\t// which consists of three consecutive 'DecalVertex' objects\r\n\r\n\t\t\tfor ( let i = 0; i < inVertices.length; i += 3 ) {\r\n\r\n\t\t\t\tlet total = 0;\r\n\t\t\t\tlet nV1;\r\n\t\t\t\tlet nV2;\r\n\t\t\t\tlet nV3;\r\n\t\t\t\tlet nV4;\r\n\r\n\t\t\t\tconst d1 = inVertices[ i + 0 ].position.dot( plane ) - s;\r\n\t\t\t\tconst d2 = inVertices[ i + 1 ].position.dot( plane ) - s;\r\n\t\t\t\tconst d3 = inVertices[ i + 2 ].position.dot( plane ) - s;\r\n\r\n\t\t\t\tconst v1Out = d1 > 0;\r\n\t\t\t\tconst v2Out = d2 > 0;\r\n\t\t\t\tconst v3Out = d3 > 0;\r\n\r\n\t\t\t\t// calculate, how many vertices of the face lie outside of the clipping plane\r\n\r\n\t\t\t\ttotal = ( v1Out ? 1 : 0 ) + ( v2Out ? 1 : 0 ) + ( v3Out ? 1 : 0 );\r\n\r\n\t\t\t\tswitch ( total ) {\r\n\r\n\t\t\t\t\tcase 0: {\r\n\r\n\t\t\t\t\t\t// the entire face lies inside of the plane, no clipping needed\r\n\r\n\t\t\t\t\t\toutVertices.push( inVertices[ i ] );\r\n\t\t\t\t\t\toutVertices.push( inVertices[ i + 1 ] );\r\n\t\t\t\t\t\toutVertices.push( inVertices[ i + 2 ] );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcase 1: {\r\n\r\n\t\t\t\t\t\t// one vertex lies outside of the plane, perform clipping\r\n\r\n\t\t\t\t\t\tif ( v1Out ) {\r\n\r\n\t\t\t\t\t\t\tnV1 = inVertices[ i + 1 ];\r\n\t\t\t\t\t\t\tnV2 = inVertices[ i + 2 ];\r\n\t\t\t\t\t\t\tnV3 = clip( inVertices[ i ], nV1, plane, s );\r\n\t\t\t\t\t\t\tnV4 = clip( inVertices[ i ], nV2, plane, s );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( v2Out ) {\r\n\r\n\t\t\t\t\t\t\tnV1 = inVertices[ i ];\r\n\t\t\t\t\t\t\tnV2 = inVertices[ i + 2 ];\r\n\t\t\t\t\t\t\tnV3 = clip( inVertices[ i + 1 ], nV1, plane, s );\r\n\t\t\t\t\t\t\tnV4 = clip( inVertices[ i + 1 ], nV2, plane, s );\r\n\r\n\t\t\t\t\t\t\toutVertices.push( nV3 );\r\n\t\t\t\t\t\t\toutVertices.push( nV2.clone() );\r\n\t\t\t\t\t\t\toutVertices.push( nV1.clone() );\r\n\r\n\t\t\t\t\t\t\toutVertices.push( nV2.clone() );\r\n\t\t\t\t\t\t\toutVertices.push( nV3.clone() );\r\n\t\t\t\t\t\t\toutVertices.push( nV4 );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( v3Out ) {\r\n\r\n\t\t\t\t\t\t\tnV1 = inVertices[ i ];\r\n\t\t\t\t\t\t\tnV2 = inVertices[ i + 1 ];\r\n\t\t\t\t\t\t\tnV3 = clip( inVertices[ i + 2 ], nV1, plane, s );\r\n\t\t\t\t\t\t\tnV4 = clip( inVertices[ i + 2 ], nV2, plane, s );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\toutVertices.push( nV1.clone() );\r\n\t\t\t\t\t\toutVertices.push( nV2.clone() );\r\n\t\t\t\t\t\toutVertices.push( nV3 );\r\n\r\n\t\t\t\t\t\toutVertices.push( nV4 );\r\n\t\t\t\t\t\toutVertices.push( nV3.clone() );\r\n\t\t\t\t\t\toutVertices.push( nV2.clone() );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcase 2: {\r\n\r\n\t\t\t\t\t\t// two vertices lies outside of the plane, perform clipping\r\n\r\n\t\t\t\t\t\tif ( ! v1Out ) {\r\n\r\n\t\t\t\t\t\t\tnV1 = inVertices[ i ].clone();\r\n\t\t\t\t\t\t\tnV2 = clip( nV1, inVertices[ i + 1 ], plane, s );\r\n\t\t\t\t\t\t\tnV3 = clip( nV1, inVertices[ i + 2 ], plane, s );\r\n\t\t\t\t\t\t\toutVertices.push( nV1 );\r\n\t\t\t\t\t\t\toutVertices.push( nV2 );\r\n\t\t\t\t\t\t\toutVertices.push( nV3 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( ! v2Out ) {\r\n\r\n\t\t\t\t\t\t\tnV1 = inVertices[ i + 1 ].clone();\r\n\t\t\t\t\t\t\tnV2 = clip( nV1, inVertices[ i + 2 ], plane, s );\r\n\t\t\t\t\t\t\tnV3 = clip( nV1, inVertices[ i ], plane, s );\r\n\t\t\t\t\t\t\toutVertices.push( nV1 );\r\n\t\t\t\t\t\t\toutVertices.push( nV2 );\r\n\t\t\t\t\t\t\toutVertices.push( nV3 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( ! v3Out ) {\r\n\r\n\t\t\t\t\t\t\tnV1 = inVertices[ i + 2 ].clone();\r\n\t\t\t\t\t\t\tnV2 = clip( nV1, inVertices[ i ], plane, s );\r\n\t\t\t\t\t\t\tnV3 = clip( nV1, inVertices[ i + 1 ], plane, s );\r\n\t\t\t\t\t\t\toutVertices.push( nV1 );\r\n\t\t\t\t\t\t\toutVertices.push( nV2 );\r\n\t\t\t\t\t\t\toutVertices.push( nV3 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcase 3: {\r\n\r\n\t\t\t\t\t\t// the entire face lies outside of the plane, so let's discard the corresponding vertices\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn outVertices;\r\n\r\n\t\t}\r\n\r\n\t\tfunction clip( v0, v1, p, s ) {\r\n\r\n\t\t\tconst d0 = v0.position.dot( p ) - s;\r\n\t\t\tconst d1 = v1.position.dot( p ) - s;\r\n\r\n\t\t\tconst s0 = d0 / ( d0 - d1 );\r\n\r\n\t\t\tconst position = new Vector3(\r\n\t\t\t\tv0.position.x + s0 * ( v1.position.x - v0.position.x ),\r\n\t\t\t\tv0.position.y + s0 * ( v1.position.y - v0.position.y ),\r\n\t\t\t\tv0.position.z + s0 * ( v1.position.z - v0.position.z )\r\n\t\t\t);\r\n\r\n\t\t\tlet normal = null;\r\n\r\n\t\t\tif ( v0.normal !== null && v1.normal !== null ) {\r\n\r\n\t\t\t\tnormal = new Vector3(\r\n\t\t\t\t\tv0.normal.x + s0 * ( v1.normal.x - v0.normal.x ),\r\n\t\t\t\t\tv0.normal.y + s0 * ( v1.normal.y - v0.normal.y ),\r\n\t\t\t\t\tv0.normal.z + s0 * ( v1.normal.z - v0.normal.z )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst v = new DecalVertex( position, normal );\r\n\r\n\t\t\t// need to clip more values (texture coordinates)? do it this way:\r\n\t\t\t// intersectpoint.value = a.value + s * ( b.value - a.value );\r\n\r\n\t\t\treturn v;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// helper\r\n\r\nclass DecalVertex {\r\n\r\n\tconstructor( position, normal = null ) {\r\n\r\n\t\tthis.position = position;\r\n\t\tthis.normal = normal;\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\tconst position = this.position.clone();\r\n\t\tconst normal = ( this.normal !== null ) ? this.normal.clone() : null;\r\n\r\n\t\treturn new this.constructor( position, normal );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { DecalGeometry, DecalVertex };\r\n"],
  "mappings": "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",
  "names": ["plane", "position"]
}
