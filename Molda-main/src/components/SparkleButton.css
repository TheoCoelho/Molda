/*
SparkleButton (uiverse.io/JkHuger/fat-bat-0)
Adaptado para a paleta do Molda via tokens CSS (HSL).

Obs: este botão é um <a> (react-router-dom <Link>), por isso resetamos estilos de link.
*/

.sp {
	position: relative;
	display: inline-block;
}

.sparkle-button {
	--active: 0;
	--transition: 0.28s;
	--spark: 1.8s;
	--cut: 0.14em;

		/*
			Base do botão (estado normal): branco com texto azul.
			O brilho/gradientes só entram com --active (hover/focus).
		*/
		--bg: hsl(0 0% 100%);
		--bg-active: radial-gradient(
				55% 70% at 50% 120%,
				hsl(var(--brand-keppel) / 0.55),
				transparent 60%
			),
			radial-gradient(
				75% 100% at 50% 120%,
				hsl(var(--brand-blue) / 0.7),
				transparent 60%
			),
			linear-gradient(135deg, hsl(var(--brand-blue) / 1), hsl(var(--brand-uv) / 1));

		background: var(--bg);

		/* reset do link */
		text-decoration: none;
		color: hsl(var(--brand-blue));

	font-size: 0.95rem;
	font-weight: 700;
	letter-spacing: 0.01em;

	border: 0;
	cursor: pointer;
	padding: 0.7rem 1.05rem;
	display: inline-flex;
	align-items: center;
	gap: 0.45em;
	white-space: nowrap;
	border-radius: 999px;
	position: relative;
	isolation: isolate;

	box-shadow:
			0 8px 22px rgba(0, 0, 0, 0.12),
			0 0 0 1px hsl(var(--brand-blue) / 0.25) inset,
			0 0 calc(var(--active) * 2.6em) calc(var(--active) * 0.7em)
				hsl(var(--brand-blue) / 0.55);

	transform: translateZ(0);
	transition:
		box-shadow var(--transition),
		transform var(--transition),
		filter var(--transition),
		background var(--transition);
}

.sparkle-button:hover,
.sparkle-button:focus-visible {
	--active: 1;
	background: var(--bg-active);
	color: hsl(var(--primary-foreground));
	transform: translateY(-1px) scale(1.02);
	filter: saturate(1.05);
}

.sparkle-button:active {
	transform: translateY(0) scale(0.99);
}

.sparkle-button:focus-visible {
	outline: 2px solid hsl(var(--ring));
	outline-offset: 2px;
}

.sparkle-button::before {
	content: "";
	position: absolute;
	inset: -0.18em;
	z-index: -1;
		border: 0.22em solid hsl(var(--brand-blue) / 0.35);
	border-radius: 999px;
	opacity: var(--active);
	transition: opacity var(--transition);
}

.spark {
	position: absolute;
	inset: 0;
	border-radius: inherit;
	overflow: hidden;
	mask: linear-gradient(white, transparent 55%);
	animation: flip calc(var(--spark) * 2) infinite steps(2, end);
	pointer-events: none;
}

@keyframes flip {
	to {
		rotate: 360deg;
	}
}

.spark::before {
	content: "";
	position: absolute;
	width: 220%;
	aspect-ratio: 1;
	top: 0;
	left: 50%;
	translate: -50% -18%;
	transform: rotate(-90deg);
	opacity: calc(var(--active) + 0.25);
	background: conic-gradient(from 0deg, transparent 0 340deg, white 360deg);
	animation: rotate var(--spark) linear infinite both;
}

@keyframes rotate {
	to {
		transform: rotate(90deg);
	}
}

.spark::after {
	content: "";
	position: absolute;
	inset: var(--cut);
	border-radius: inherit;
}

.backdrop {
	position: absolute;
	inset: var(--cut);
	border-radius: inherit;
	/*
	  Importante: o backdrop fica POR CIMA do background do botão.
	  Se ele tiver background próprio, ele pode "travar" a cor e parecer que o hover não funciona.
	  Então deixamos transparente e o fundo vem do próprio botão.
	*/
	background: transparent;
	transition: background var(--transition);
	pointer-events: none;
	z-index: -1;
}

.sparkle-button svg.sparkle {
	inline-size: 1.2em;
	translate: -0.05em -0.02em;
}

.sparkle path {
	/* ícone acompanha o estado */
	color: hsl(0 0% calc((var(--active) * 85%) + 10%));
	fill: currentColor;
	stroke: currentColor;
	transform-box: fill-box;
	transform-origin: center;
	animation-delay: calc((var(--transition) * 1.4) + (var(--delay, 0) * 1s));
	animation-duration: 0.6s;
	transition: color var(--transition);
}

.sparkle-button:is(:hover, :focus-visible) .sparkle path {
	animation-name: bounce;
}

@keyframes bounce {
	35%,
	65% {
		scale: var(--scale);
	}
}

.sparkle path:nth-of-type(1) {
	--scale: 0.65;
	--delay: 0.1;
}
.sparkle path:nth-of-type(2) {
	--scale: 1.35;
	--delay: 0.2;
}
.sparkle path:nth-of-type(3) {
	--scale: 2.15;
	--delay: 0.34;
}

.sparkle-text {
	/*
		Estado normal: texto azul sólido.
		Hover/focus: vira branco (segue o `color` do botão).
	*/
	color: currentColor;
	transition: color var(--transition);
}

.particle-pen {
	position: absolute;
	width: 200%;
	aspect-ratio: 1;
	top: 50%;
	left: 50%;
	translate: -50% -50%;
	mask: radial-gradient(white, transparent 65%);
	-webkit-mask: radial-gradient(white, transparent 65%);
	z-index: -2;
	opacity: var(--active);
	transition: opacity var(--transition);
	pointer-events: none;
}

.particle {
	width: calc(var(--size, 0.26) * 1rem);
	aspect-ratio: 1;
	position: absolute;
	top: calc(var(--y) * 1%);
	left: calc(var(--x) * 1%);
	opacity: var(--alpha, 1);
	animation: float-out calc(var(--duration, 1) * 1s) calc(var(--delay) * -1s)
		infinite linear;
	transform-origin: var(--origin-x, 1000%) var(--origin-y, 1000%);
	animation-play-state: paused;
}

.sparkle-button:is(:hover, :focus-visible) ~ .particle-pen .particle {
	animation-play-state: running;
}

.particle path {
	fill: hsl(var(--brand-keppel) / 0.75);
}

.particle:nth-of-type(even) {
	animation-direction: reverse;
}

@keyframes float-out {
	to {
		rotate: 360deg;
	}
}

/* posições fixas (12 partículas) */
.particle:nth-of-type(1) {
	--x: 20;
	--y: 35;
	--duration: 1;
	--delay: 0.1;
	--size: 0.3;
	--origin-x: -120%;
	--origin-y: -150%;
}
.particle:nth-of-type(2) {
	--x: 60;
	--y: 20;
	--duration: 1.2;
	--delay: 0.2;
	--size: 0.22;
	--origin-x: 140%;
	--origin-y: -180%;
}
.particle:nth-of-type(3) {
	--x: 82;
	--y: 56;
	--duration: 1.5;
	--delay: 0.3;
	--size: 0.32;
	--origin-x: 180%;
	--origin-y: 130%;
}
.particle:nth-of-type(4) {
	--x: 10;
	--y: 78;
	--duration: 1.1;
	--delay: 0.4;
	--size: 0.2;
	--origin-x: -150%;
	--origin-y: 170%;
}
.particle:nth-of-type(5) {
	--x: 90;
	--y: 30;
	--duration: 1.3;
	--delay: 0.5;
	--size: 0.26;
	--origin-x: 220%;
	--origin-y: -120%;
}
.particle:nth-of-type(6) {
	--x: 30;
	--y: 70;
	--duration: 1.4;
	--delay: 0.6;
	--size: 0.28;
	--origin-x: -120%;
	--origin-y: 120%;
}
.particle:nth-of-type(7) {
	--x: 70;
	--y: 54;
	--duration: 1.6;
	--delay: 0.7;
	--size: 0.22;
	--origin-x: 140%;
	--origin-y: 80%;
}
.particle:nth-of-type(8) {
	--x: 40;
	--y: 14;
	--duration: 1.2;
	--delay: 0.8;
	--size: 0.3;
	--origin-x: -80%;
	--origin-y: -200%;
}
.particle:nth-of-type(9) {
	--x: 50;
	--y: 92;
	--duration: 1.5;
	--delay: 0.9;
	--size: 0.24;
	--origin-x: 0%;
	--origin-y: 200%;
}
.particle:nth-of-type(10) {
	--x: 96;
	--y: 44;
	--duration: 1.1;
	--delay: 1.0;
	--size: 0.2;
	--origin-x: 220%;
	--origin-y: 60%;
}
.particle:nth-of-type(11) {
	--x: 24;
	--y: 54;
	--duration: 1.3;
	--delay: 1.1;
	--size: 0.26;
	--origin-x: -160%;
	--origin-y: 90%;
}
.particle:nth-of-type(12) {
	--x: 66;
	--y: 86;
	--duration: 1.4;
	--delay: 1.2;
	--size: 0.25;
	--origin-x: 120%;
	--origin-y: 150%;
}

/* uiverse hook: quando não existe :has() suportado, o bodydrop existiria.
	 Mantemos o elemento mas não precisamos fazer nada aqui. */
.bodydrop {
	display: none;
}

/* reduz animações quando prefer-reduced-motion */
@media (prefers-reduced-motion: reduce) {
	.spark,
	.particle {
		animation: none !important;
	}
	.sparkle-button {
		transition: none !important;
	}
}
